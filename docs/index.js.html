<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var node_fs = require('node:fs');
var undici = require('undici');
var http = require('http');
var https = require('https');
var node_buffer = require('node:buffer');
var net = require('node:net');
var tls = require('node:tls');
var crypto = require('node:crypto');

function _interopDefault (e) { return e &amp;&amp; e.__esModule ? e : { default: e }; }

var http__default = /*#__PURE__*/_interopDefault(http);
var https__default = /*#__PURE__*/_interopDefault(https);
var net__default = /*#__PURE__*/_interopDefault(net);
var tls__default = /*#__PURE__*/_interopDefault(tls);
var crypto__default = /*#__PURE__*/_interopDefault(crypto);

// Log level configuration with console methods and criticality levels. &lt;br>
// Higher criticality values indicate more important messages.
const LOG_LEVELS = {
    error: {
        log: console.error,
        criticality: 3
    },
    warn: {
        log: console.warn,
        criticality: 2
    },
    info: {
        log: console.info,
        criticality: 1
    },
    debug: {
        log: console.debug,
        criticality: 0
    }
};
// Default logging criticality level. Messages with criticality below this level are ignored.
const DEFAULT_CRITICALITY = LOG_LEVELS.info.criticality;
/**
 * Simple logger to write log messages to the console. &lt;br>
 * Supported logging levels are `error`, `warn`, `info` and `debug`. &lt;br>
 * Throws an error if logging level is invalid.
 *
 * @param {'error'|'warn'|'info'|'debug'} level - The log level for the message
 * @param {string | Error} message - The message to log, either a string or Error object
 */ function log(level, message) {
    const logLevel = LOG_LEVELS[level];
    if (!logLevel) {
        throw new Error(`Invalid log level: '${level}'`);
    }
    if (logLevel.criticality >= DEFAULT_CRITICALITY) {
        logLevel.log(message);
    }
}

/**
 * Type guard to check if a value is a boolean.
 * @param {unknown} value - The value to check
 * @returns True if the value is a boolean, false otherwise
 */ function isBoolean(value) {
    return typeof value === "boolean";
}
/**
 * Type guard to check if a value is an integer within specified bounds.
 * @param {unknown} value - The value to check
 * @param {number} lowerBound - The minimum allowed value (inclusive)
 * @returns True if the value is an integer >= lowerBound, false otherwise
 */ function isInteger(value, lowerBound) {
    return typeof value === "number" &amp;&amp; Number.isInteger(value) &amp;&amp; value >= lowerBound;
}
/**
 * Converts a timestamp from the specified unit to microseconds.
 * @param {bigint} timestamp - The timestamp value as a bigint
 * @param {TimestampUnit} unit - The source timestamp unit
 * @returns The timestamp converted to microseconds
 * @throws Error if the timestamp unit is unknown
 */ function timestampToMicros(timestamp, unit) {
    switch(unit){
        case "ns":
            return timestamp / 1000n;
        case "us":
            return timestamp;
        case "ms":
            return timestamp * 1000n;
        default:
            throw new Error(`Unknown timestamp unit: ${unit}`);
    }
}
/**
 * Converts a timestamp from the specified unit to nanoseconds.
 * @param {bigint} timestamp - The timestamp value as a bigint
 * @param {TimestampUnit} unit - The source timestamp unit
 * @returns The timestamp converted to nanoseconds
 * @throws Error if the timestamp unit is unknown
 */ function timestampToNanos(timestamp, unit) {
    switch(unit){
        case "ns":
            return timestamp;
        case "us":
            return timestamp * 1000n;
        case "ms":
            return timestamp * 1000_000n;
        default:
            throw new Error(`Unknown timestamp unit: ${unit}`);
    }
}
/**
 * Analyzes the dimensions of a nested array structure.
 * @param {unknown} data - The array to analyze
 * @returns Array of dimension sizes at each nesting level
 * @throws Error if any dimension has zero length
 */ function getDimensions(data) {
    const dimensions = [];
    while(Array.isArray(data)){
        dimensions.push(data.length);
        data = data[0];
    }
    return dimensions;
}
/**
 * Validates an array structure. &lt;br>
 * Validation fails if:
 * - &lt;i>data&lt;/i> is not an array
 * - the array is irregular: the length of its sub-arrays are different
 * - the array is not homogenous: the array contains mixed types
 * @param {unknown[]} data - The array to validate
 * @param {number[]} dimensions - The shape of the array
 * @returns The primitive type of the array's elements
 * @throws Error if the validation fails
 */ function validateArray(data, dimensions) {
    if (data === null || data === undefined) {
        return null;
    }
    if (!Array.isArray(data)) {
        throw new Error(`The value must be an array [value=${JSON.stringify(data)}, type=${typeof data}]`);
    }
    let expectedType = null;
    function checkArray(array, depth = 0, path = "") {
        const expectedLength = dimensions[depth];
        if (array.length !== expectedLength) {
            throw new Error(`Lengths of sub-arrays do not match [expected=${expectedLength}, actual=${array.length}, dimensions=[${dimensions}], path=${path}]`);
        }
        if (depth &lt; dimensions.length - 1) {
            // intermediate level, expecting arrays
            for(let i = 0; i &lt; array.length; i++){
                if (!Array.isArray(array[i])) {
                    throw new Error(`Mixed types found [expected=array, current=${typeof array[i]}, path=${path}[${i}]]`);
                }
                checkArray(array[i], depth + 1, `${path}[${i}]`);
            }
        } else {
            // leaf level, expecting primitives
            if (expectedType === null &amp;&amp; array[0] !== undefined) {
                expectedType = typeof array[0];
            }
            for(let i = 0; i &lt; array.length; i++){
                const currentType = typeof array[i];
                if (currentType !== expectedType) {
                    throw new Error(expectedType !== null ? `Mixed types found [expected=${expectedType}, current=${currentType}, path=${path}[${i}]]` : `Unsupported array type [type=${currentType}]`);
                }
            }
        }
    }
    checkArray(data);
    return expectedType;
}
/**
 * Fetches JSON data from a URL.
 * @template T - The expected type of the JSON response
 * @param {string} url - The URL to fetch from
 * @param {Agent} agent - HTTP agent to be used for the request
 * @param {number} timeout - Request timeout, query will be aborted if not finished in time
 * @returns Promise resolving to the parsed JSON data
 * @throws Error if the request fails or returns a non-OK status
 */ async function fetchJson(url, timeout, agent) {
    const controller = new AbortController();
    const { signal } = controller;
    const timeoutId = setTimeout(()=>controller.abort(), timeout);
    let response;
    try {
        response = await fetch(url, {
            dispatcher: agent,
            signal
        });
    } catch (error) {
        throw new Error(`Failed to load ${url} [error=${error}]`);
    } finally{
        clearTimeout(timeoutId);
    }
    if (!response.ok) {
        throw new Error(`Failed to load ${url} [statusCode=${response.status} (${response.statusText})]`);
    }
    return await response.json();
}

// @ts-check
// HTTP status code for successful request with no content.
const HTTP_NO_CONTENT = 204;
// Default number of rows that trigger auto-flush for HTTP transport.
const DEFAULT_HTTP_AUTO_FLUSH_ROWS = 75000;
// Default minimum throughput for HTTP requests (100 KB/sec).
const DEFAULT_REQUEST_MIN_THROUGHPUT = 102400;
// Default request timeout in milliseconds (10 seconds).
const DEFAULT_REQUEST_TIMEOUT = 10000;
// Default retry timeout in milliseconds (10 seconds).
const DEFAULT_RETRY_TIMEOUT = 10000;
// HTTP status codes that should trigger request retries.
// Includes server errors and gateway timeouts that may be transient.
const RETRIABLE_STATUS_CODES = [
    500,
    503,
    504,
    507,
    509,
    523,
    524,
    529,
    599
];
/**
 * Abstract base class for HTTP-based transport implementations. &lt;br>
 * Provides common configuration and functionality for HTTP and HTTPS protocols.
 */ class HttpTransportBase {
    /**
   * Creates a new HttpTransportBase instance.
   *
   * @param {SenderOptions} options - Sender configuration options including connection and authentication details
   * @throws Error if required protocol or host options are missing
   */ constructor(options){
        if (!options || !options.protocol) {
            throw new Error("The 'protocol' option is mandatory");
        }
        if (!options.host) {
            throw new Error("The 'host' option is mandatory");
        }
        this.log = typeof options.log === "function" ? options.log : log;
        this.tlsVerify = isBoolean(options.tls_verify) ? options.tls_verify : true;
        this.tlsCA = options.tls_ca ? node_fs.readFileSync(options.tls_ca) : undefined;
        this.username = options.username;
        this.password = options.password;
        this.token = options.token;
        if (!options.port) {
            options.port = 9000;
        }
        this.host = options.host;
        this.port = options.port;
        this.requestMinThroughput = isInteger(options.request_min_throughput, 0) ? options.request_min_throughput : DEFAULT_REQUEST_MIN_THROUGHPUT;
        this.requestTimeout = isInteger(options.request_timeout, 1) ? options.request_timeout : DEFAULT_REQUEST_TIMEOUT;
        this.retryTimeout = isInteger(options.retry_timeout, 0) ? options.retry_timeout : DEFAULT_RETRY_TIMEOUT;
        switch(options.protocol){
            case HTTP:
                this.secure = false;
                break;
            case HTTPS:
                this.secure = true;
                break;
            default:
                throw new Error("The 'protocol' has to be 'http' or 'https' for the HTTP transport");
        }
    }
    /**
   * HTTP transport does not require explicit connection establishment.
   * @throws Error indicating connect is not required for HTTP transport
   */ connect() {
        throw new Error("'connect()' is not required for HTTP transport");
    }
    /**
   * HTTP transport does not require explicit connection closure.
   * @returns Promise that resolves immediately
   */ async close() {}
    /**
   * Gets the default auto-flush row count for HTTP transport.
   * @returns {number} Default number of rows that trigger auto-flush
   */ getDefaultAutoFlushRows() {
        return DEFAULT_HTTP_AUTO_FLUSH_ROWS;
    }
}

const HTTP_PORT = 9000;
const TCP_PORT = 9009;
const HTTP = "http";
const HTTPS = "https";
const TCP = "tcp";
const TCPS = "tcps";
const ON = "on";
const OFF = "off";
const UNSAFE_OFF = "unsafe_off";
const PROTOCOL_VERSION_AUTO = "auto";
const PROTOCOL_VERSION_V1 = "1";
const PROTOCOL_VERSION_V2 = "2";
const LINE_PROTO_SUPPORT_VERSION = "line.proto.support.versions";
/** @classdesc
 * &lt;a href="Sender.html">Sender&lt;/a> configuration options. &lt;br>
 * &lt;br>
 * Properties of the object are initialized through a configuration string. &lt;br>
 * The configuration string has the following format: &lt;i>&amp;ltprotocol&amp;gt::&amp;ltkey&amp;gt=&amp;ltvalue&amp;gt;&amp;ltkey&amp;gt=&amp;ltvalue&amp;gt;...;&lt;/i> &lt;br>
 * The keys are case-sensitive, the trailing semicolon is optional. &lt;br>
 * The values are validated and an error is thrown if the format is invalid. &lt;br>
 * &lt;br>
 * Connection and protocol options
 * &lt;ul>
 * &lt;li> &lt;b>protocol&lt;/b>: &lt;i>enum, accepted values: http, https, tcp, tcps&lt;/i> - The protocol used to communicate with the server. &lt;br>
 * When &lt;i>https&lt;/i> or &lt;i>tcps&lt;/i> used, the connection is secured with TLS encryption.
 * &lt;/li>
 * &lt;li> &lt;b>protocol_version&lt;/b>: &lt;i>enum, accepted values: auto, 1, 2&lt;/i> - The protocol version used for data serialization. &lt;br>
 * Version 1 uses text-based serialization for all data types. Version 2 uses binary encoding for doubles and arrays. &lt;br>
 * When set to 'auto' (default for HTTP/HTTPS), the client automatically negotiates the highest supported version with the server. &lt;br>
 * TCP/TCPS connections default to version 1.
 * &lt;/li>
 * &lt;li> addr: &lt;i>string&lt;/i> - Hostname and port, separated by colon. This key is mandatory, but the port part is optional. &lt;br>
 * If no port is specified, a default will be used. &lt;br>
 * When the protocol is HTTP/HTTPS, the port defaults to 9000. When the protocol is TCP/TCPS, the port defaults to 9009. &lt;br>
 * &lt;br>
 * Examples: &lt;i>http::addr=localhost:9000&lt;/i>, &lt;i>https::addr=localhost:9000&lt;/i>, &lt;i>http::addr=localhost&lt;/i>, &lt;i>tcp::addr=localhost:9009&lt;/i>
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * Authentication options
 * &lt;ul>
 * &lt;li> username: &lt;i>string&lt;/i> - Used for authentication. &lt;br>
 * For HTTP, Basic Authentication requires the &lt;i>password&lt;/i> option. &lt;br>
 * For TCP with JWK token authentication, &lt;i>token&lt;/i> option is required.
 * &lt;/li>
 * &lt;li> password: &lt;i>string&lt;/i> - Password for HTTP Basic authentication, should be accompanied by the &lt;i>username&lt;/i> option.
 * &lt;/li>
 * &lt;li> token: &lt;i>string&lt;/i> - For HTTP with Bearer authentication, this is the bearer token. &lt;br>
 * For TCP with JWK token authentication, this is the private key part of the JWK token,
 * and must be accompanied by the &lt;i>username&lt;/i> option.
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * TLS options
 * &lt;ul>
 * &lt;li> tls_verify: &lt;i>enum, accepted values: on, unsafe_off&lt;/i> - When the HTTPS or TCPS protocols are selected, TLS encryption is used. &lt;br>
 * By default, the Sender will verify the server's certificate, but this check can be disabled by setting this option to &lt;i>unsafe_off&lt;/i>. &lt;br>
 * This is useful in non-production environments where self-signed certificates might be used, but should be avoided in production if possible.
 * &lt;/li>
 * &lt;li> tls_ca: &lt;i>string&lt;/i> - Path to a file containing the root CA's certificate in PEM format. &lt;br>
 * Can be useful when self-signed certificates are used, otherwise should not be set.
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * Auto flush options
 * &lt;ul>
 * &lt;li> auto_flush: &lt;i>enum, accepted values: on, off&lt;/i> - The Sender automatically flushes the buffer by default. This can be switched off
 * by setting this option to &lt;i>off&lt;/i>. &lt;br>
 * When disabled, the flush() method of the Sender has to be called explicitly to make sure data is sent to the server. &lt;br>
 * Manual buffer flushing can be useful, especially when we want to control transaction boundaries. &lt;br>
 * When the HTTP protocol is used, each flush results in a single HTTP request, which becomes a single transaction on the server side. &lt;br>
 * The transaction either succeeds, and all rows sent in the request are inserted; or it fails, and none of the rows make it into the database.
 * &lt;/li>
 * &lt;li> auto_flush_rows: &lt;i>integer&lt;/i> - The number of rows that will trigger a flush. When set to 0, row-based flushing is disabled. &lt;br>
 * The Sender will default this parameter to 75000 rows when HTTP protocol is used, and to 600 in case of TCP protocol.
 * &lt;/li>
 * &lt;li> auto_flush_interval: &lt;i>integer&lt;/i> - The number of milliseconds that will trigger a flush, default value is 1000.
 * When set to 0, interval-based flushing is disabled. &lt;br>
 * Note that the setting is checked only when a new row is added to the buffer. There is no timer registered to flush the buffer automatically.
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * Buffer sizing options
 * &lt;ul>
 * &lt;li> init_buf_size: &lt;i>integer&lt;/i> - Initial buffer size, defaults to 64 KiB in the Sender.
 * &lt;/li>
 * &lt;li> max_buf_size: &lt;i>integer&lt;/i> - Maximum buffer size, defaults to 100 MiB in the Sender. &lt;br>
 * If the buffer would need to be extended beyond the maximum size, an error is thrown.
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * HTTP request specific options
 * &lt;ul>
 * &lt;li> request_timeout: &lt;i>integer&lt;/i> - The time in milliseconds to wait for a response from the server, set to 10 seconds by default. &lt;br>
 * This is in addition to the calculation derived from the &lt;i>request_min_throughput&lt;/i> parameter.
 * &lt;/li>
 * &lt;li> request_min_throughput: &lt;i>integer&lt;/i> - Minimum expected throughput in bytes per second for HTTP requests, set to 100 KiB/s seconds by default. &lt;br>
 * If the throughput is lower than this value, the connection will time out. This is used to calculate an additional
 * timeout on top of &lt;i>request_timeout&lt;/i>. This is useful for large requests. You can set this value to 0 to disable this logic.
 * &lt;/li>
 * &lt;li> retry_timeout: &lt;i>integer&lt;/i> - The time in milliseconds to continue retrying after a failed HTTP request, set to 10 seconds by default. &lt;br>
 * The interval between retries is an exponential backoff starting at 10ms and doubling after each failed attempt up to a maximum of 1 second.
 * &lt;/li>
 * &lt;/ul>
 * &lt;br>
 * Other options
 * &lt;ul>
 * &lt;li> stdlib_http: &lt;i>enum, accepted values: on, off&lt;/i> - With HTTP protocol the Undici library is used by default. By setting this option
 * to &lt;i>on&lt;/i> the client switches to node's core http and https modules.
 * &lt;/li>
 * &lt;li> max_name_len: &lt;i>integer&lt;/i> - The maximum length of a table or column name, the Sender defaults this parameter to 127. &lt;br>
 * Recommended to use the same setting as the server, which also uses 127 by default.
 * &lt;/li>
 * &lt;/ul>
 */ class SenderOptions {
    /**
   * Creates a Sender options object by parsing the provided configuration string.
   *
   * @param {string} configurationString - Configuration string. &lt;br>
   * @param {object} extraOptions - Optional extra configuration. &lt;br>
   * - 'log' is a logging function used by the &lt;a href="Sender.html">Sender&lt;/a>. &lt;br>
   * Prototype: &lt;i>(level: 'error'|'warn'|'info'|'debug', message: string) => void&lt;/i>. &lt;br>
   * - 'agent' is a custom http/https agent used by the &lt;a href="Sender.html">Sender&lt;/a> when http/https transport is used. &lt;br>
   * Depends on which transport implementation and protocol used, one of the followings expected: &lt;i>undici.Agent&lt;/i>, &lt;i>http.Agent&lt;/i> or &lt;i>https.Agent&lt;/i>.
   */ constructor(configurationString, extraOptions){
        parseConfigurationString(this, configurationString);
        if (extraOptions) {
            if (extraOptions.log &amp;&amp; typeof extraOptions.log !== "function") {
                throw new Error("Invalid logging function");
            }
            this.log = extraOptions.log;
            if (extraOptions.agent &amp;&amp; !(extraOptions.agent instanceof undici.Agent) &amp;&amp; !(extraOptions.agent instanceof http__default.default.Agent) &amp;&amp; // @ts-expect-error - Not clear what the problem is, the two lines above have no issues
            !(extraOptions.agent instanceof https__default.default.Agent)) {
                throw new Error("Invalid HTTP agent");
            }
            this.agent = extraOptions.agent;
        }
    }
    /**
   * Resolves the protocol version, if it is set to 'auto'. &lt;br>
   * If TCP transport is used, the protocol version will default to 1.
   * In case of HTTP transport the &lt;i>/settings&lt;/i> endpoint of the database is used to find the protocol versions
   * supported by the server, and the highest will be selected.
   * When calling the &lt;i>/settings&lt;/i> endpoint the timeout and TLs options are used from the &lt;i>options&lt;/i> object.
   * @param {SenderOptions} options SenderOptions instance needs resolving protocol version
   */ static async resolveAuto(options) {
        parseProtocolVersion(options);
        if (options.protocol_version !== PROTOCOL_VERSION_AUTO) {
            return options;
        }
        const url = `${options.protocol}://${options.host}:${options.port}/settings`;
        const settings = await fetchJson(url, isInteger(options.request_timeout, 1) ? options.request_timeout : DEFAULT_REQUEST_TIMEOUT, new undici.Agent({
            connect: {
                ca: options.tls_ca ? node_fs.readFileSync(options.tls_ca) : undefined,
                rejectUnauthorized: isBoolean(options.tls_verify) ? options.tls_verify : true
            }
        }));
        const supportedVersions = (settings.config[LINE_PROTO_SUPPORT_VERSION] ?? []).map((version)=>String(version));
        if (supportedVersions.length === 0) {
            options.protocol_version = PROTOCOL_VERSION_V1;
        } else if (supportedVersions.includes(PROTOCOL_VERSION_V2)) {
            options.protocol_version = PROTOCOL_VERSION_V2;
        } else if (supportedVersions.includes(PROTOCOL_VERSION_V1)) {
            options.protocol_version = PROTOCOL_VERSION_V1;
        } else {
            throw new Error("Unsupported protocol versions received from server: " + supportedVersions);
        }
        return options;
    }
    static resolveDeprecated(options, log) {
        if (!options) {
            return;
        }
        // deal with deprecated options
        if (options.copy_buffer !== undefined) {
            log("warn", `Option 'copy_buffer' is not supported anymore, please, remove it`);
            options.copy_buffer = undefined;
        }
        if (options.copyBuffer !== undefined) {
            log("warn", `Option 'copyBuffer' is not supported anymore, please, remove it`);
            options.copyBuffer = undefined;
        }
        if (options.bufferSize !== undefined) {
            log("warn", `Option 'bufferSize' is not supported anymore, please, replace it with 'init_buf_size'`);
            options.init_buf_size = options.bufferSize;
            options.bufferSize = undefined;
        }
    }
    /**
   * Creates a Sender options object by parsing the provided configuration string.
   *
   * @param {string} configurationString - Configuration string. &lt;br>
   * @param {object} extraOptions - Optional extra configuration. &lt;br>
   * - 'log' is a logging function used by the &lt;a href="Sender.html">Sender&lt;/a>. &lt;br>
   * Prototype: &lt;i>(level: 'error'|'warn'|'info'|'debug', message: string) => void&lt;/i>. &lt;br>
   * - 'agent' is a custom http/https agent used by the &lt;a href="Sender.html">Sender&lt;/a> when http/https transport is used. &lt;br>
   * Depends on which transport implementation and protocol used, one of the followings expected: &lt;i>undici.Agent&lt;/i>, &lt;i>http.Agent&lt;/i> or &lt;i>https.Agent&lt;/i>.
   *
   * @return {SenderOptions} A Sender configuration object initialized from the provided configuration string.
   */ static async fromConfig(configurationString, extraOptions) {
        const options = new SenderOptions(configurationString, extraOptions);
        await SenderOptions.resolveAuto(options);
        return options;
    }
    /**
   * Creates a Sender options object by parsing the configuration string set in the &lt;b>QDB_CLIENT_CONF&lt;/b> environment variable.
   *
   * @param {object} extraOptions - Optional extra configuration. &lt;br>
   * - 'log' is a logging function used by the &lt;a href="Sender.html">Sender&lt;/a>. &lt;br>
   * Prototype: &lt;i>(level: 'error'|'warn'|'info'|'debug', message: string) => void&lt;/i>. &lt;br>
   * - 'agent' is a custom http/https agent used by the &lt;a href="Sender.html">Sender&lt;/a> when http/https transport is used. &lt;br>
   * Depends on which transport implementation and protocol used, one of the followings expected: &lt;i>undici.Agent&lt;/i>, &lt;i>http.Agent&lt;/i> or &lt;i>https.Agent&lt;/i>.
   *
   * @return {SenderOptions} A Sender configuration object initialized from the &lt;b>QDB_CLIENT_CONF&lt;/b> environment variable.
   */ static async fromEnv(extraOptions) {
        return await SenderOptions.fromConfig(process.env.QDB_CLIENT_CONF, extraOptions);
    }
}
function parseConfigurationString(options, configString) {
    if (!configString) {
        throw new Error("Configuration string is missing or empty");
    }
    const position = parseProtocol(options, configString);
    parseSettings(options, configString, position);
    parseProtocolVersion(options);
    parseAddress(options);
    parseBufferSizes(options);
    parseAutoFlushOptions(options);
    parseTlsOptions(options);
    parseRequestTimeoutOptions(options);
    parseMaxNameLength(options);
    parseStdlibTransport(options);
}
function parseSettings(options, configString, position) {
    let index = configString.indexOf(";", position);
    while(index > -1){
        if (index + 1 &lt; configString.length &amp;&amp; configString.charAt(index + 1) === ";") {
            index = configString.indexOf(";", index + 2);
            continue;
        }
        parseSetting(options, configString, position, index);
        position = index + 1;
        index = configString.indexOf(";", position);
    }
    if (position &lt; configString.length) {
        parseSetting(options, configString, position, configString.length);
    }
}
function parseSetting(options, configString, position, index) {
    const setting = configString.slice(position, index).replaceAll(";;", ";");
    const equalsIndex = setting.indexOf("=");
    if (equalsIndex &lt; 0) {
        throw new Error(`Missing '=' sign in '${setting}'`);
    }
    const key = setting.slice(0, equalsIndex);
    const value = setting.slice(equalsIndex + 1);
    validateConfigKey(key);
    validateConfigValue(key, value);
    options[key] = value;
}
const ValidConfigKeys = [
    "protocol_version",
    "addr",
    "username",
    "password",
    "token",
    "token_x",
    "token_y",
    "auto_flush",
    "auto_flush_rows",
    "auto_flush_interval",
    "request_min_throughput",
    "request_timeout",
    "retry_timeout",
    "init_buf_size",
    "max_buf_size",
    "max_name_len",
    "stdlib_http",
    "tls_verify",
    "tls_ca",
    "tls_roots",
    "tls_roots_password"
];
function validateConfigKey(key) {
    if (!ValidConfigKeys.includes(key)) {
        throw new Error(`Unknown configuration key: '${key}'`);
    }
}
function validateConfigValue(key, value) {
    if (!value) {
        throw new Error(`Invalid configuration, value is not set for '${key}'`);
    }
    for(let i = 0; i &lt; value.length; i++){
        const unicode = value.codePointAt(i);
        if (unicode &lt; 0x20 || unicode > 0x7e &amp;&amp; unicode &lt; 0xa0) {
            throw new Error(`Invalid configuration, control characters are not allowed: '${value}'`);
        }
    }
}
function parseProtocol(options, configString) {
    const index = configString.indexOf("::");
    if (index &lt; 0) {
        throw new Error("Missing protocol, configuration string format: 'protocol::key1=value1;key2=value2;key3=value3;'");
    }
    options.protocol = configString.slice(0, index);
    switch(options.protocol){
        case HTTP:
        case HTTPS:
        case TCP:
        case TCPS:
            break;
        default:
            throw new Error(`Invalid protocol: '${options.protocol}', accepted protocols: 'http', 'https', 'tcp', 'tcps'`);
    }
    return index + 2;
}
function parseProtocolVersion(options) {
    const protocol_version = options.protocol_version ?? PROTOCOL_VERSION_AUTO;
    switch(protocol_version){
        case PROTOCOL_VERSION_AUTO:
            switch(options.protocol){
                case HTTP:
                case HTTPS:
                    options.protocol_version = PROTOCOL_VERSION_AUTO;
                    break;
                default:
                    options.protocol_version = PROTOCOL_VERSION_V1;
            }
            break;
        case PROTOCOL_VERSION_V1:
        case PROTOCOL_VERSION_V2:
            break;
        default:
            throw new Error(`Invalid protocol version: '${protocol_version}', accepted values: 'auto', '1', '2'`);
    }
    return;
}
function parseAddress(options) {
    if (!options.addr) {
        throw new Error("Invalid configuration, 'addr' is required");
    }
    const index = options.addr.indexOf(":");
    if (index &lt; 0) {
        options.host = options.addr;
        switch(options.protocol){
            case HTTP:
            case HTTPS:
                options.port = HTTP_PORT;
                return;
            case TCP:
            case TCPS:
                options.port = TCP_PORT;
                return;
            default:
                throw new Error(`Invalid protocol: '${options.protocol}', accepted protocols: 'http', 'https', 'tcp', 'tcps'`);
        }
    }
    options.host = options.addr.slice(0, index);
    if (!options.host) {
        throw new Error(`Host name is required`);
    }
    const portStr = options.addr.slice(index + 1);
    if (!portStr) {
        throw new Error(`Port is required`);
    }
    options.port = Number(portStr);
    if (isNaN(options.port)) {
        throw new Error(`Invalid port: '${portStr}'`);
    }
    if (!Number.isInteger(options.port) || options.port &lt; 1) {
        throw new Error(`Invalid port: ${options.port}`);
    }
}
function parseBufferSizes(options) {
    parseInteger(options, "init_buf_size", "initial buffer size", 1);
    parseInteger(options, "max_buf_size", "max buffer size", 1);
}
function parseAutoFlushOptions(options) {
    parseBoolean(options, "auto_flush", "auto flush");
    parseInteger(options, "auto_flush_rows", "auto flush rows", 0);
    parseInteger(options, "auto_flush_interval", "auto flush interval", 0);
}
function parseTlsOptions(options) {
    parseBoolean(options, "tls_verify", "TLS verify", UNSAFE_OFF);
    if (options.tls_roots || options.tls_roots_password) {
        throw new Error("'tls_roots' and 'tls_roots_password' options are not supported, please, " + "use the 'tls_ca' option or the NODE_EXTRA_CA_CERTS environment variable instead");
    }
}
function parseRequestTimeoutOptions(options) {
    parseInteger(options, "request_min_throughput", "request min throughput", 1);
    parseInteger(options, "request_timeout", "request timeout", 1);
    parseInteger(options, "retry_timeout", "retry timeout", 0);
}
function parseMaxNameLength(options) {
    parseInteger(options, "max_name_len", "max name length", 1);
}
function parseStdlibTransport(options) {
    parseBoolean(options, "stdlib_http", "stdlib http");
}
function parseBoolean(options, property, description, offValue = OFF) {
    if (options[property]) {
        const property_str = options[property];
        switch(property_str){
            case ON:
                options[property] = true;
                break;
            case offValue:
                options[property] = false;
                break;
            default:
                throw new Error(`Invalid ${description} option: '${property_str}'`);
        }
    }
}
function parseInteger(options, property, description, lowerBound) {
    if (options[property]) {
        const property_str = options[property];
        options[property] = Number(property_str);
        if (isNaN(options[property])) {
            throw new Error(`Invalid ${description} option, not a number: '${property_str}'`);
        }
        if (!Number.isInteger(options[property]) || options[property] &lt; lowerBound) {
            throw new Error(`Invalid ${description} option: ${options[property]}`);
        }
    }
}

// @ts-check
/**
 * Default HTTP options for the Undici agent.
 * Configures keep-alive connections with 60-second timeout and single request pipelining.
 */ const DEFAULT_HTTP_OPTIONS = {
    connect: {
        keepAlive: true
    },
    pipelining: 1,
    keepAliveTimeout: 60000
};
/**
 * HTTP transport implementation using the Undici library. &lt;br>
 * Provides high-performance HTTP requests with connection pooling and retry logic. &lt;br>
 * Supports both HTTP and HTTPS protocols with configurable authentication.
 */ class UndiciTransport extends HttpTransportBase {
    /**
   * Creates a new UndiciTransport instance.
   *
   * @param options - Sender configuration object containing connection and retry settings
   * @throws Error if the protocol is not 'http' or 'https'
   */ constructor(options){
        super(options);
        switch(options.protocol){
            case HTTP:
                this.agent = options.agent instanceof undici.Agent ? options.agent : UndiciTransport.getDefaultHttpAgent();
                break;
            case HTTPS:
                if (options.agent instanceof undici.Agent) {
                    this.agent = options.agent;
                } else {
                    // Create a new agent with instance-specific TLS options
                    this.agent = new undici.Agent({
                        ...DEFAULT_HTTP_OPTIONS,
                        connect: {
                            ...DEFAULT_HTTP_OPTIONS.connect,
                            requestCert: this.tlsVerify,
                            rejectUnauthorized: this.tlsVerify,
                            ca: this.tlsCA
                        }
                    });
                }
                break;
            default:
                throw new Error("The 'protocol' has to be 'http' or 'https' for the Undici HTTP transport");
        }
        this.dispatcher = new undici.RetryAgent(this.agent, {
            maxRetries: Infinity,
            minTimeout: 10,
            maxTimeout: 1000,
            timeoutFactor: 2,
            retryAfter: true,
            methods: [
                "GET",
                "POST",
                "PUT",
                "DELETE",
                "PATCH",
                "OPTIONS",
                "HEAD"
            ],
            statusCodes: RETRIABLE_STATUS_CODES,
            errorCodes: [
                "ECONNRESET",
                "EAI_AGAIN",
                "ECONNREFUSED",
                "ETIMEDOUT",
                "EPIPE",
                "UND_ERR_CONNECT_TIMEOUT",
                "UND_ERR_HEADERS_TIMEOUT",
                "UND_ERR_BODY_TIMEOUT"
            ]
        });
    }
    /**
   * Sends data to QuestDB using HTTP POST.
   *
   * @param {Buffer} data - Buffer containing the data to send
   * @returns Promise resolving to true if data was sent successfully
   * @throws Error if request fails after all retries or times out
   */ async send(data) {
        const headers = {};
        if (this.token) {
            headers["Authorization"] = `Bearer ${this.token}`;
        } else if (this.username &amp;&amp; this.password) {
            headers["Authorization"] = `Basic ${node_buffer.Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
        }
        const controller = new AbortController();
        const { signal } = controller;
        setTimeout(()=>controller.abort(), this.retryTimeout);
        let responseData;
        try {
            const timeoutMillis = data.length / this.requestMinThroughput * 1000 + this.requestTimeout;
            responseData = await this.dispatcher.request({
                origin: `${this.secure ? "https" : "http"}://${this.host}:${this.port}`,
                path: "/write?precision=n",
                method: "POST",
                headers,
                body: data,
                headersTimeout: this.requestTimeout,
                bodyTimeout: timeoutMillis,
                signal
            });
        } catch (err) {
            if (err.name === "AbortError") {
                throw new Error("HTTP request timeout, no response from server in time");
            } else {
                throw err;
            }
        }
        const { statusCode } = responseData;
        const body = await responseData.body.arrayBuffer();
        if (statusCode === HTTP_NO_CONTENT) {
            if (body.byteLength > 0) {
                const message = node_buffer.Buffer.from(body).toString();
                const logMessage = message.length &lt; 256 ? message : `${message.substring(0, 256)}... (truncated, full length=${message.length})`;
                this.log("warn", `Unexpected message from server: ${logMessage}`);
            }
            return true;
        } else {
            throw new Error(`HTTP request failed, statusCode=${statusCode}, error=${node_buffer.Buffer.from(body).toString()}`);
        }
    }
    /**
   * @ignore
   * Gets or creates the default HTTP agent with standard configuration.
   * Uses a singleton pattern to reuse the same agent across instances.
   * @returns The default Undici agent instance
   */ static getDefaultHttpAgent() {
        if (!UndiciTransport.DEFAULT_HTTP_AGENT) {
            UndiciTransport.DEFAULT_HTTP_AGENT = new undici.Agent(DEFAULT_HTTP_OPTIONS);
        }
        return UndiciTransport.DEFAULT_HTTP_AGENT;
    }
}

// @ts-check
// Default number of rows that trigger auto-flush for TCP transport.
const DEFAULT_TCP_AUTO_FLUSH_ROWS = 600;
// Arbitrary public key, used to construct valid JWK tokens.
// These are not used for actual authentication, only required for crypto API compatibility.
const PUBLIC_KEY = {
    x: "aultdA0PjhD_cWViqKKyL5chm6H1n-BiZBo_48T-uqc",
    y: "__ptaol41JWSpTTL525yVEfzmY8A6Vi_QrW1FjKcHMg"
};
/**
 * TCP transport implementation. &lt;br>
 * Supports both plain TCP or secure TLS-encrypted connections with configurable JWK token authentication.
 */ class TcpTransport {
    /**
   * Creates a new TcpTransport instance.
   *
   * @param {SenderOptions} options - Sender configuration object containing connection and authentication details
   * @throws Error if required options are missing or protocol is not 'tcp' or 'tcps'
   */ constructor(options){
        if (!options || !options.protocol) {
            throw new Error("The 'protocol' option is mandatory");
        }
        if (!options.host) {
            throw new Error("The 'host' option is mandatory");
        }
        this.log = typeof options.log === "function" ? options.log : log;
        this.tlsVerify = isBoolean(options.tls_verify) ? options.tls_verify : true;
        this.tlsCA = options.tls_ca ? node_fs.readFileSync(options.tls_ca) : undefined;
        this.host = options.host;
        this.port = options.port;
        switch(options.protocol){
            case TCP:
                this.secure = false;
                break;
            case TCPS:
                this.secure = true;
                break;
            default:
                throw new Error("The 'protocol' has to be 'tcp' or 'tcps' for the TCP transport");
        }
        if (!options.auth &amp;&amp; !options.jwk) {
            constructAuth(options);
        }
        this.jwk = constructJwk(options);
        if (!options.port) {
            options.port = 9009;
        }
    }
    /**
   * Creates a TCP connection to the database.
   * @returns Promise resolving to true if the connection is established successfully
   * @throws Error if connection fails or authentication is rejected
   */ connect() {
        const connOptions = {
            host: this.host,
            port: this.port,
            ca: this.tlsCA
        };
        return new Promise((resolve, reject)=>{
            if (this.socket) {
                throw new Error("Sender connected already");
            }
            let authenticated = false;
            let data;
            this.socket = !this.secure ? net__default.default.connect(connOptions) : tls__default.default.connect(connOptions, ()=>{
                if (authenticated) {
                    resolve(true);
                }
            });
            this.socket.setKeepAlive(true);
            this.socket.on("data", async (raw)=>{
                data = !data ? raw : node_buffer.Buffer.concat([
                    data,
                    raw
                ]);
                if (!authenticated) {
                    authenticated = await this.authenticate(data);
                    if (authenticated) {
                        resolve(true);
                    }
                } else {
                    this.log("warn", `Received unexpected data: ${data}`);
                }
            }).on("ready", async ()=>{
                this.log("info", `Successfully connected to ${connOptions.host}:${connOptions.port}`);
                if (this.jwk) {
                    this.log("info", `Authenticating with ${connOptions.host}:${connOptions.port}`);
                    this.socket.write(`${this.jwk.kid}\n`, (err)=>err ? reject(err) : ()=>{});
                } else {
                    authenticated = true;
                    if (!this.secure || !this.tlsVerify) {
                        resolve(true);
                    }
                }
            }).on("error", (err)=>{
                this.log("error", err);
                if (this.tlsVerify || !err.code || err.code !== "SELF_SIGNED_CERT_IN_CHAIN") {
                    reject(err);
                }
            });
        });
    }
    /**
   * Sends data over the established TCP connection.
   * @param {Buffer} data - Buffer containing the data to send
   * @returns Promise resolving to true if data was sent successfully
   * @throws Error if the data could not be written to the socket
   */ send(data) {
        if (!this.socket || this.socket.destroyed) {
            throw new Error("TCP transport is not connected");
        }
        return new Promise((resolve, reject)=>{
            this.socket.write(data, (err)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve(true);
                }
            });
        });
    }
    /**
   * Closes the TCP connection to the database.
   */ async close() {
        if (this.socket) {
            const address = this.socket.remoteAddress;
            const port = this.socket.remotePort;
            this.socket.destroy();
            this.socket = null;
            this.log("info", `Connection to ${address}:${port} is closed`);
        }
    }
    /**
   * Gets the default auto-flush row count for TCP transport.
   * @returns Default number of rows that trigger auto-flush
   */ getDefaultAutoFlushRows() {
        return DEFAULT_TCP_AUTO_FLUSH_ROWS;
    }
    /**
   * @ignore
   * Handles the JWK token authentication challenge-response flow.
   * @param {Buffer} challenge - Challenge buffer received from the server
   * @returns Promise resolving to true if authentication is successful
   */ async authenticate(challenge) {
        // Check for trailing \n which ends the challenge
        if (challenge.subarray(-1).readInt8() === 10) {
            const keyObject = crypto__default.default.createPrivateKey({
                key: this.jwk,
                format: "jwk"
            });
            const signature = crypto__default.default.sign("RSA-SHA256", challenge.subarray(0, challenge.length - 1), keyObject);
            return new Promise((resolve, reject)=>{
                this.socket.write(`${node_buffer.Buffer.from(signature).toString("base64")}\n`, (err)=>{
                    if (err) {
                        reject(err);
                    } else {
                        resolve(true);
                    }
                });
            });
        }
        return false;
    }
}
/**
 * @ignore
 * Constructs authentication configuration from username/token options.
 * @param {SenderOptions} options - Sender options that may contain authentication details
 * @throws Error if username or token is missing when authentication is intended
 */ function constructAuth(options) {
    if (!options.username &amp;&amp; !options.token &amp;&amp; !options.password) {
        // no intention to authenticate
        return;
    }
    if (!options.username || !options.token) {
        throw new Error("TCP transport requires a username and a private key for authentication, " + "please, specify the 'username' and 'token' config options");
    }
    options.auth = {
        keyId: options.username,
        token: options.token
    };
}
/**
 * @ignore
 * Constructs a JWK (JSON Web Key) object for cryptographic authentication.
 * @param {SenderOptions} options - Sender options containing authentication configuration
 * @returns JWK object with key ID, private key, and public key coordinates
 * @throws Error if required authentication properties are missing or invalid
 */ function constructJwk(options) {
    if (options.auth) {
        if (!options.auth.keyId) {
            throw new Error("Missing username, please, specify the 'keyId' property of the 'auth' config option. " + "For example: new Sender({protocol: 'tcp', host: 'host', auth: {keyId: 'username', token: 'private key'}})");
        }
        if (typeof options.auth.keyId !== "string") {
            throw new Error("Please, specify the 'keyId' property of the 'auth' config option as a string. " + "For example: new Sender({protocol: 'tcp', host: 'host', auth: {keyId: 'username', token: 'private key'}})");
        }
        if (!options.auth.token) {
            throw new Error("Missing private key, please, specify the 'token' property of the 'auth' config option. " + "For example: new Sender({protocol: 'tcp', host: 'host', auth: {keyId: 'username', token: 'private key'}})");
        }
        if (typeof options.auth.token !== "string") {
            throw new Error("Please, specify the 'token' property of the 'auth' config option as a string. " + "For example: new Sender({protocol: 'tcp', host: 'host', auth: {keyId: 'username', token: 'private key'}})");
        }
        return {
            kid: options.auth.keyId,
            d: options.auth.token,
            ...PUBLIC_KEY,
            kty: "EC",
            crv: "P-256"
        };
    } else {
        return options.jwk;
    }
}

// @ts-check
/**
 * Default configuration for HTTP agents.
 * - Persistent connections with 1 minute idle timeout
 * - Maximum of 256 open connections (matching server default)
 */ const DEFAULT_HTTP_AGENT_CONFIG = {
    maxSockets: 256,
    keepAlive: true,
    timeout: 60000
};
/**
 * HTTP transport implementation using Node.js built-in http/https modules. &lt;br>
 * Supports both HTTP and HTTPS protocols with configurable authentication.
 */ class HttpTransport extends HttpTransportBase {
    /**
   * Creates a new HttpTransport instance using Node.js HTTP modules.
   *
   * @param {SenderOptions} options - Sender configuration object containing connection details
   * @throws Error if the protocol is not 'http' or 'https'
   */ constructor(options){
        super(options);
        switch(options.protocol){
            case HTTP:
                this.agent = options.agent instanceof http__default.default.Agent ? options.agent : HttpTransport.getDefaultHttpAgent();
                break;
            case HTTPS:
                this.agent = options.agent instanceof https__default.default.Agent ? options.agent : HttpTransport.getDefaultHttpsAgent();
                break;
            default:
                throw new Error("The 'protocol' has to be 'http' or 'https' for the HTTP transport");
        }
    }
    /**
   * Sends data to QuestDB using HTTP POST.
   *
   * @param {Buffer} data - Buffer containing the data to send
   * @param {number} retryBegin - Internal parameter for tracking retry start time
   * @param {number} retryInterval - Internal parameter for tracking retry intervals
   * @returns Promise resolving to true if data was sent successfully
   * @throws Error if request fails after all retries or times out
   */ send(data, retryBegin = -1, retryInterval = -1) {
        const request = this.secure ? https__default.default.request : http__default.default.request;
        const timeoutMillis = data.length / this.requestMinThroughput * 1000 + this.requestTimeout;
        const options = this.createRequestOptions(timeoutMillis);
        return new Promise((resolve, reject)=>{
            let statusCode = -1;
            const req = request(options, (response)=>{
                statusCode = response.statusCode;
                const body = [];
                response.on("data", (chunk)=>{
                    body.push(chunk);
                }).on("error", (err)=>{
                    this.log("error", `resp err=${err}`);
                });
                if (statusCode === HTTP_NO_CONTENT) {
                    response.on("end", ()=>{
                        if (body.length > 0) {
                            const message = node_buffer.Buffer.concat(body).toString();
                            const logMessage = message.length &lt; 256 ? message : `${message.substring(0, 256)}... (truncated, full length=${message.length})`;
                            this.log("warn", `Unexpected message from server: ${logMessage}`);
                        }
                        resolve(true);
                    });
                } else {
                    req.destroy(new Error(`HTTP request failed, statusCode=${statusCode}, error=${node_buffer.Buffer.concat(body)}`));
                }
            });
            if (this.token) {
                req.setHeader("Authorization", `Bearer ${this.token}`);
            } else if (this.username &amp;&amp; this.password) {
                req.setHeader("Authorization", `Basic ${node_buffer.Buffer.from(`${this.username}:${this.password}`).toString("base64")}`);
            }
            req.on("timeout", ()=>{
                // set a retryable error code
                statusCode = 524;
                req.destroy(new Error("HTTP request timeout, no response from server in time"));
            });
            req.on("error", (err)=>{
                // if the error is thrown while the request is sent, statusCode is -1 => no retry
                // request timeout comes through with statusCode 524 => retry
                // if the error is thrown while the response is processed, the statusCode is taken from the response => retry depends on statusCode
                if (isRetryable(statusCode) &amp;&amp; this.retryTimeout > 0) {
                    if (retryBegin &lt; 0) {
                        retryBegin = Date.now();
                        retryInterval = 10;
                    } else {
                        const elapsed = Date.now() - retryBegin;
                        if (elapsed > this.retryTimeout) {
                            reject(err);
                            return;
                        }
                    }
                    const jitter = Math.floor(Math.random() * 10) - 5;
                    setTimeout(()=>{
                        retryInterval = Math.min(retryInterval * 2, 1000);
                        this.send(data, retryBegin, retryInterval).then(()=>resolve(true)).catch((e)=>reject(e));
                    }, retryInterval + jitter);
                } else {
                    reject(err);
                }
            });
            req.write(data, (err)=>err ? reject(err) : ()=>{});
            req.end();
        });
    }
    /**
   * @ignore
   * Creates HTTP request options based on configuration.
   *
   * @param {number} timeoutMillis - Request timeout in milliseconds
   * @returns HTTP or HTTPS request options object
   */ createRequestOptions(timeoutMillis) {
        return {
            hostname: this.host,
            port: this.port,
            agent: this.agent,
            path: "/write?precision=n",
            method: "POST",
            timeout: timeoutMillis,
            rejectUnauthorized: this.secure &amp;&amp; this.tlsVerify,
            ca: this.secure ? this.tlsCA : undefined
        };
    }
    /**
   * @ignore
   * Gets or creates the default HTTP agent with standard configuration.
   * Uses a singleton pattern to reuse the same agent across instances.
   * @returns The default HTTP agent instance
   */ static getDefaultHttpAgent() {
        if (!HttpTransport.DEFAULT_HTTP_AGENT) {
            HttpTransport.DEFAULT_HTTP_AGENT = new http__default.default.Agent(DEFAULT_HTTP_AGENT_CONFIG);
        }
        return HttpTransport.DEFAULT_HTTP_AGENT;
    }
    /**
   * @ignore
   * Gets or creates the default HTTPS agent with standard configuration.
   * Uses a singleton pattern to reuse the same agent across instances.
   * @returns The default HTTPS agent instance
   */ static getDefaultHttpsAgent() {
        if (!HttpTransport.DEFAULT_HTTPS_AGENT) {
            HttpTransport.DEFAULT_HTTPS_AGENT = new https__default.default.Agent(DEFAULT_HTTP_AGENT_CONFIG);
        }
        return HttpTransport.DEFAULT_HTTPS_AGENT;
    }
}
/**
 * @ignore
 * Determines if an HTTP status code should trigger a retry.
 * @param {number} statusCode - HTTP status code to check
 * @returns True if the status code indicates a retryable error
 */ function isRetryable(statusCode) {
    return RETRIABLE_STATUS_CODES.includes(statusCode);
}

// @ts-check
/**
 * Factory function to create appropriate transport instance based on configuration.
 * @param {SenderOptions} options - Sender configuration options including protocol and connection details
 * @returns Transport instance appropriate for the specified protocol
 * @throws Error if protocol or host options are missing or invalid
 */ function createTransport(options) {
    if (!options || !options.protocol) {
        throw new Error("The 'protocol' option is mandatory");
    }
    if (!options.host) {
        throw new Error("The 'host' option is mandatory");
    }
    switch(options.protocol){
        case HTTP:
        case HTTPS:
            return options.stdlib_http ? new HttpTransport(options) : new UndiciTransport(options);
        case TCP:
        case TCPS:
            return new TcpTransport(options);
        default:
            throw new Error(`Invalid protocol: '${options.protocol}'`);
    }
}

/**
 * Validates a table name.
 *
 * @param {string} name - The table name to validate.
 * @param {number} maxNameLength - The maximum length of table names.
 * @throws Error if table name is invalid.
 */ function validateTableName(name, maxNameLength) {
    const len = name.length;
    if (len > maxNameLength) {
        throw new Error(`Table name is too long, max length is ${maxNameLength}`);
    }
    if (len === 0) {
        throw new Error("Empty string is not allowed as table name");
    }
    for(let i = 0; i &lt; len; i++){
        const ch = name[i];
        switch(ch){
            case ".":
                if (i === 0 || i === len - 1 || name[i - 1] === ".") // single dot is allowed in the middle only
                // starting with a dot hides directory in Linux
                // ending with a dot can be trimmed by some Windows versions / file systems
                // double or triple dot looks suspicious
                // single dot allowed as compatibility,
                // when someone uploads 'file_name.csv' the file name used as the table name
                throw new Error("Table name cannot start or end with a dot, and only a single dot allowed");
                break;
            case "?":
            case ",":
            case "'":
            case '"':
            case "\\":
            case "/":
            case ":":
            case ")":
            case "(":
            case "+":
            case "*":
            case "%":
            case "~":
            case "\u0000":
            case "\u0001":
            case "\u0002":
            case "\u0003":
            case "\u0004":
            case "\u0005":
            case "\u0006":
            case "\u0007":
            case "\u0008":
            case "\u0009":
            case "\u000B":
            case "\u000c":
            case "\r":
            case "\n":
            case "\u000e":
            case "\u000f":
            case "\u007f":
            case "\ufeff":
                throw new Error(`Invalid character in table name: ${ch}`);
        }
    }
}
/**
 * Validates a column name.
 *
 * @param {string} name - The column name to validate.
 * @param {number} maxNameLength - The maximum length of column names.
 * @throws Error if column name is invalid.
 */ function validateColumnName(name, maxNameLength) {
    const len = name.length;
    if (len > maxNameLength) {
        throw new Error(`Column name is too long, max length is ${maxNameLength}`);
    }
    if (len === 0) {
        throw new Error("Empty string is not allowed as column name");
    }
    for (const ch of name){
        switch(ch){
            case "?":
            case ".":
            case ",":
            case "'":
            case '"':
            case "\\":
            case "/":
            case ":":
            case ")":
            case "(":
            case "+":
            case "-":
            case "*":
            case "%":
            case "~":
            case "\u0000":
            case "\u0001":
            case "\u0002":
            case "\u0003":
            case "\u0004":
            case "\u0005":
            case "\u0006":
            case "\u0007":
            case "\u0008":
            case "\u0009":
            case "\u000B":
            case "\u000c":
            case "\r":
            case "\n":
            case "\u000e":
            case "\u000f":
            case "\u007f":
            case "\ufeff":
                throw new Error(`Invalid character in column name: ${ch}`);
        }
    }
}

// @ts-check
// Default maximum length for table and column names.
const DEFAULT_MAX_NAME_LENGTH = 127;
/**
 * Abstract base class for SenderBuffer implementations. &lt;br>
 * Provides common functionality for writing data into the buffer.
 */ class SenderBufferBase {
    /**
   * Creates an instance of SenderBufferBase.
   *
   * @param {SenderOptions} options - Sender configuration object. &lt;br>
   * See SenderOptions documentation for detailed description of configuration options.
   */ constructor(options){
        this.log = options &amp;&amp; typeof options.log === "function" ? options.log : log;
        SenderOptions.resolveDeprecated(options, this.log);
        this.maxNameLength = options &amp;&amp; isInteger(options.max_name_len, 1) ? options.max_name_len : DEFAULT_MAX_NAME_LENGTH;
        this.maxBufferSize = options &amp;&amp; isInteger(options.max_buf_size, 1) ? options.max_buf_size : DEFAULT_MAX_BUFFER_SIZE;
        this.resize(options &amp;&amp; isInteger(options.init_buf_size, 1) ? options.init_buf_size : DEFAULT_BUFFER_SIZE);
        this.reset();
    }
    /**
   * @ignore
   * Resizes the buffer. &lt;br>
   * Can be used to increase the size of the buffer if data to be written would not fit.
   * Creates a new buffer, and copies the content of the old buffer into the new one.
   *
   * @param {number} bufferSize - New size of the buffer used by the sender, provided in bytes
   * @throws Error if the requested buffer size exceeds the maximum allowed size
   */ resize(bufferSize) {
        if (bufferSize > this.maxBufferSize) {
            throw new Error(`Max buffer size is ${this.maxBufferSize} bytes, requested buffer size: ${bufferSize}`);
        }
        this.bufferSize = bufferSize;
        const newBuffer = node_buffer.Buffer.alloc(this.bufferSize, 0);
        if (this.buffer) {
            this.buffer.copy(newBuffer);
        }
        this.buffer = newBuffer;
    }
    /**
   * Resets the buffer, data sitting in the buffer will be lost. &lt;br>
   * In other words it clears the buffer, and sets the writing position to the beginning of the buffer.
   *
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ reset() {
        this.position = 0;
        this.startNewRow();
        return this;
    }
    startNewRow() {
        this.endOfLastRow = this.position;
        this.hasTable = false;
        this.hasSymbols = false;
        this.hasColumns = false;
    }
    /**
   * @return {Buffer} Returns a cropped buffer, or null if there is nothing to send. &lt;br>
   * The returned buffer is backed by this buffer instance, meaning the view can change as the buffer is mutated.
   * Used only in tests to assert the buffer's content.
   */ toBufferView(pos = this.endOfLastRow) {
        return pos > 0 ? this.buffer.subarray(0, pos) : null;
    }
    /**
   * @return {Buffer} Returns a cropped buffer ready to send to the server, or null if there is nothing to send. &lt;br>
   * The returned buffer is a copy of this buffer.
   * It also compacts the buffer.
   */ toBufferNew(pos = this.endOfLastRow) {
        if (pos > 0) {
            const data = node_buffer.Buffer.allocUnsafe(pos);
            this.buffer.copy(data, 0, 0, pos);
            this.compact();
            return data;
        }
        return null;
    }
    /**
   * Writes the table name into the buffer.
   *
   * @param {string} table - Table name.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ table(table) {
        if (typeof table !== "string") {
            throw new Error(`Table name must be a string, received ${typeof table}`);
        }
        if (this.hasTable) {
            throw new Error("Table name has already been set");
        }
        validateTableName(table, this.maxNameLength);
        this.checkCapacity([
            table
        ], table.length);
        this.writeEscaped(table);
        this.hasTable = true;
        return this;
    }
    /**
   * Writes a symbol name and value into the buffer. &lt;br>
   * Use it to insert into SYMBOL columns.
   *
   * @param {string} name - Symbol name.
   * @param {unknown} value - Symbol value, toString() is called to extract the actual symbol value from the parameter.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ symbol(name, value) {
        if (typeof name !== "string") {
            throw new Error(`Symbol name must be a string, received ${typeof name}`);
        }
        if (!this.hasTable || this.hasColumns) {
            throw new Error("Symbol can be added only after table name is set and before any column added");
        }
        const valueStr = value.toString();
        this.checkCapacity([
            name,
            valueStr
        ], 2 + name.length + valueStr.length);
        this.write(",");
        validateColumnName(name, this.maxNameLength);
        this.writeEscaped(name);
        this.write("=");
        this.writeEscaped(valueStr);
        this.hasSymbols = true;
        return this;
    }
    /**
   * Writes a string column with its value into the buffer. &lt;br>
   * Use it to insert into VARCHAR and STRING columns.
   *
   * @param {string} name - Column name.
   * @param {string} value - Column value, accepts only string values.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ stringColumn(name, value) {
        this.writeColumn(name, value, ()=>{
            this.checkCapacity([
                value
            ], 2 + value.length);
            this.write('"');
            this.writeEscaped(value, true);
            this.write('"');
        }, "string");
        return this;
    }
    /**
   * Writes a boolean column with its value into the buffer. &lt;br>
   * Use it to insert into BOOLEAN columns.
   *
   * @param {string} name - Column name.
   * @param {boolean} value - Column value, accepts only boolean values.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ booleanColumn(name, value) {
        this.writeColumn(name, value, ()=>{
            this.checkCapacity([], 1);
            this.write(value ? "t" : "f");
        }, "boolean");
        return this;
    }
    /**
   * Writes a 64-bit signed integer into the buffer. &lt;br>
   * Use it to insert into LONG, INT, SHORT and BYTE columns.
   *
   * @param {string} name - Column name.
   * @param {number} value - Column value, accepts only number values.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   * @throws Error if the value is not an integer
   */ intColumn(name, value) {
        if (!Number.isInteger(value)) {
            throw new Error(`Value must be an integer, received ${value}`);
        }
        this.writeColumn(name, value, ()=>{
            const valueStr = value.toString();
            this.checkCapacity([
                valueStr
            ], 1);
            this.write(valueStr);
            this.write("i");
        });
        return this;
    }
    /**
   * Writes a timestamp column with its value into the buffer. &lt;br>
   * Use it to insert into TIMESTAMP columns.
   *
   * @param {string} name - Column name.
   * @param {number | bigint} value - Epoch timestamp, accepts numbers or BigInts.
   * @param {string} [unit=us] - Timestamp unit. Supported values: 'ns' - nanoseconds, 'us' - microseconds, 'ms' - milliseconds. Defaults to 'us'.
   * @return {SenderBuffer} Returns with a reference to this buffer.
   */ timestampColumn(name, value, unit = "us") {
        if (typeof value !== "bigint" &amp;&amp; !Number.isInteger(value)) {
            throw new Error(`Value must be an integer or BigInt, received ${value}`);
        }
        this.writeColumn(name, value, ()=>{
            const valueMicros = timestampToMicros(BigInt(value), unit);
            const valueStr = valueMicros.toString();
            this.checkCapacity([
                valueStr
            ], 1);
            this.write(valueStr);
            this.write("t");
        });
        return this;
    }
    /**
   * Closes the row after writing the designated timestamp into the buffer.
   *
   * @param {number | bigint} timestamp - Designated epoch timestamp, accepts numbers or BigInts.
   * @param {string} [unit=us] - Timestamp unit. Supported values: 'ns' - nanoseconds, 'us' - microseconds, 'ms' - milliseconds. Defaults to 'us'.
   */ at(timestamp, unit = "us") {
        if (!this.hasSymbols &amp;&amp; !this.hasColumns) {
            throw new Error("The row must have a symbol or column set before it is closed");
        }
        if (typeof timestamp !== "bigint" &amp;&amp; !Number.isInteger(timestamp)) {
            throw new Error(`Designated timestamp must be an integer or BigInt, received ${timestamp}`);
        }
        const timestampNanos = timestampToNanos(BigInt(timestamp), unit);
        const timestampStr = timestampNanos.toString();
        this.checkCapacity([
            timestampStr
        ], 2);
        this.write(" ");
        this.write(timestampStr);
        this.write("\n");
        this.startNewRow();
    }
    /**
   * Closes the row without writing designated timestamp into the buffer. &lt;br>
   * Designated timestamp will be populated by the server on this record.
   */ atNow() {
        if (!this.hasSymbols &amp;&amp; !this.hasColumns) {
            throw new Error("The row must have a symbol or column set before it is closed");
        }
        this.checkCapacity([], 1);
        this.write("\n");
        this.startNewRow();
    }
    /**
   * Returns the current position of the buffer. &lt;br>
   * New data will be written into the buffer starting from this position.
   */ currentPosition() {
        return this.position;
    }
    /**
   * Checks if the buffer has sufficient capacity for additional data and resizes if needed.
   * @param data - Array of strings to calculate the required capacity for
   * @param base - Base number of bytes to add to the calculation
   */ checkCapacity(data, base = 0) {
        let length = base;
        for (const str of data){
            length += node_buffer.Buffer.byteLength(str, "utf8");
        }
        if (this.position + length > this.bufferSize) {
            let newSize = this.bufferSize;
            do {
                newSize += this.bufferSize;
            }while (this.position + length > newSize)
            this.resize(newSize);
        }
    }
    /**
   * @ignore
   * Compacts the buffer by removing completed rows.
   * Moves any remaining data to the beginning of the buffer.
   */ compact() {
        if (this.endOfLastRow > 0) {
            this.buffer.copy(this.buffer, 0, this.endOfLastRow, this.position);
            this.position = this.position - this.endOfLastRow;
            this.endOfLastRow = 0;
        }
    }
    /**
   * @ignore
   * Common logic for writing column data to the buffer.
   * @param name - Column name
   * @param value - Column value
   * @param writeValue - Function to write the value portion to the buffer
   * @param valueType - Optional expected type for validation
   */ writeColumn(name, value, writeValue, valueType) {
        if (typeof name !== "string") {
            throw new Error(`Column name must be a string, received ${typeof name}`);
        }
        if (valueType &amp;&amp; typeof value !== valueType) {
            throw new Error(`Column value must be of type ${valueType}, received ${typeof value}`);
        }
        if (!this.hasTable) {
            throw new Error("Column can be set only after table name is set");
        }
        this.checkCapacity([
            name
        ], 2 + name.length);
        this.write(this.hasColumns ? "," : " ");
        validateColumnName(name, this.maxNameLength);
        this.writeEscaped(name);
        this.write("=");
        writeValue();
        this.hasColumns = true;
    }
    /**
   * @ignore
   * Writes string data to the buffer at the current position.
   * @param data - String data to write
   */ write(data) {
        this.position += this.buffer.write(data, this.position);
    }
    /**
   * @ignore
   * Writes a single byte to the buffer at the current position.
   * @param data - Byte value to write
   */ writeByte(data) {
        this.position = this.buffer.writeInt8(data, this.position);
    }
    /**
   * @ignore
   * Writes a 32-bit integer to the buffer in little-endian format.
   * @param data - Integer value to write
   */ writeInt(data) {
        this.position = this.buffer.writeInt32LE(data, this.position);
    }
    /**
   * @ignore
   * Writes a double-precision float to the buffer in little-endian format.
   * @param data - Double value to write
   */ writeDouble(data) {
        this.position = this.buffer.writeDoubleLE(data, this.position);
    }
    writeEscaped(data, quoted = false) {
        for (const ch of data){
            if (ch > "\\") {
                this.write(ch);
                continue;
            }
            switch(ch){
                case " ":
                case ",":
                case "=":
                    if (!quoted) {
                        this.write("\\");
                    }
                    this.write(ch);
                    break;
                case "\n":
                case "\r":
                    this.write("\\");
                    this.write(ch);
                    break;
                case '"':
                    if (quoted) {
                        this.write("\\");
                    }
                    this.write(ch);
                    break;
                case "\\":
                    this.write("\\\\");
                    break;
                default:
                    this.write(ch);
                    break;
            }
        }
    }
}

// @ts-check
/**
 * Buffer implementation for protocol version 1.
 * Sends floating point numbers in their text form.
 */ class SenderBufferV1 extends SenderBufferBase {
    /**
   * Creates a new SenderBufferV1 instance.
   *
   * @param {SenderOptions} options - Sender configuration object. &lt;br>
   * See SenderOptions documentation for detailed description of configuration options.   */ constructor(options){
        super(options);
    }
    /**
   * Writes a 64-bit floating point value into the buffer using v1 serialization (text format). &lt;br>
   * Use it to insert into DOUBLE or FLOAT database columns.
   *
   * @param {string} name - Column name.
   * @param {number} value - Column value, accepts only number values.
   * @return {Sender} Returns with a reference to this sender.
   */ floatColumn(name, value) {
        this.writeColumn(name, value, ()=>{
            const valueStr = value.toString();
            this.checkCapacity([
                valueStr
            ]);
            this.write(valueStr);
        }, "number");
        return this;
    }
    /**
   * Array columns are not supported in protocol v1.
   *
   * @throws Error indicating arrays are not supported in v1
   */ arrayColumn() {
        throw new Error("Arrays are not supported in protocol v1");
    }
}

// @ts-check
// Column type constants for protocol v2.
const COLUMN_TYPE_DOUBLE = 10;
const COLUMN_TYPE_NULL = 33;
// Entity type constants for protocol v2.
const ENTITY_TYPE_ARRAY = 14;
const ENTITY_TYPE_DOUBLE = 16;
// ASCII code for equals sign used in binary protocol.
const EQUALS_SIGN = "=".charCodeAt(0);
/**
 * Buffer implementation for protocol version 2.
 * Sends floating point numbers in binary form.
 */ class SenderBufferV2 extends SenderBufferBase {
    /**
   * Creates a new SenderBufferV2 instance.
   *
   * @param {SenderOptions} options - Sender configuration object. &lt;br>
   * See SenderOptions documentation for detailed description of configuration options.
   */ constructor(options){
        super(options);
    }
    /**
   * Writes a 64-bit floating point value into the buffer using v2 serialization (binary format). &lt;br>
   * Use it to insert into DOUBLE or FLOAT database columns.
   *
   * @param {string} name - Column name.
   * @param {number} value - Column value, accepts only number values.
   * @returns {Sender} Returns with a reference to this buffer.
   */ floatColumn(name, value) {
        this.writeColumn(name, value, ()=>{
            this.checkCapacity([], 10);
            this.writeByte(EQUALS_SIGN);
            this.writeByte(ENTITY_TYPE_DOUBLE);
            this.writeDouble(value);
        }, "number");
        return this;
    }
    /**
   * Write an array column with its values into the buffer using v2 format.
   *
   * @param {string} name - Column name
   * @param {unknown[]} value - Array values to write (currently supports double arrays)
   * @returns {Sender} Returns with a reference to this buffer.
   * @throws Error if array validation fails:
   * - value is not an array
   * - or the shape of the array is irregular: the length of sub-arrays are different
   * - or the array is not homogeneous: its elements are not all the same type
   */ arrayColumn(name, value) {
        const dimensions = getDimensions(value);
        const type = validateArray(value, dimensions);
        // only number arrays and NULL supported for now
        if (type !== "number" &amp;&amp; type !== null) {
            throw new Error(`Unsupported array type [type=${type}]`);
        }
        this.writeColumn(name, value, ()=>{
            this.checkCapacity([], 3);
            this.writeByte(EQUALS_SIGN);
            this.writeByte(ENTITY_TYPE_ARRAY);
            if (!value) {
                this.writeByte(COLUMN_TYPE_NULL);
            } else {
                this.writeByte(COLUMN_TYPE_DOUBLE);
                this.writeArray(value, dimensions, type);
            }
        });
        return this;
    }
    writeArray(arr, dimensions, type) {
        this.checkCapacity([], 1 + dimensions.length * 4);
        this.writeByte(dimensions.length);
        for(let i = 0; i &lt; dimensions.length; i++){
            this.writeInt(dimensions[i]);
        }
        this.checkCapacity([], SenderBufferV2.arraySize(dimensions, type));
        this.writeArrayValues(arr, dimensions);
    }
    writeArrayValues(arr, dimensions) {
        if (Array.isArray(arr[0])) {
            for(let i = 0; i &lt; arr.length; i++){
                this.writeArrayValues(arr[i], dimensions);
            }
        } else {
            const type = arr[0] !== undefined ? typeof arr[0] : null;
            switch(type){
                case "number":
                    for(let i = 0; i &lt; arr.length; i++){
                        this.position = this.buffer.writeDoubleLE(arr[i], this.position);
                    }
                    break;
                case null:
                    break;
                default:
                    throw new Error(`Unsupported array type [type=${type}]`);
            }
        }
    }
    static arraySize(dimensions, type) {
        let numOfElements = 1;
        for(let i = 0; i &lt; dimensions.length; i++){
            numOfElements *= dimensions[i];
        }
        switch(type){
            case "number":
                return numOfElements * 8;
            case "boolean":
                return numOfElements;
            case "string":
                // in case of string[] capacity check is done separately for each array element
                return 0;
            case null:
                // empty array
                return 0;
            default:
                throw new Error(`Unsupported array type [type=${type}]`);
        }
    }
}

// @ts-check
// Default initial buffer size in bytes (64 KB).
const DEFAULT_BUFFER_SIZE = 65536; //  64 KB
// Default maximum buffer size in bytes (100 MB).
const DEFAULT_MAX_BUFFER_SIZE = 104857600; // 100 MB
/**
 * Factory function to create a SenderBuffer instance based on the protocol version.
 *
 * @param {SenderOptions} options - Sender configuration object. &lt;br>
 * See SenderOptions documentation for detailed description of configuration options.
 *
 * @returns A SenderBuffer instance appropriate for the specified protocol version
 * @throws Error if protocol version is not specified or is unsupported
 */ function createBuffer(options) {
    switch(options.protocol_version){
        case PROTOCOL_VERSION_V2:
            return new SenderBufferV2(options);
        case PROTOCOL_VERSION_V1:
            return new SenderBufferV1(options);
        case PROTOCOL_VERSION_AUTO:
        case undefined:
        case null:
        case "":
            throw new Error("Provide the 'protocol_version' option, or call 'await SenderOptions.resolveAuto(options)' first");
        default:
            throw new Error("Unsupported protocol version: " + options.protocol_version);
    }
}

// @ts-check
const DEFAULT_AUTO_FLUSH_INTERVAL = 1000; // 1 sec
/** @classdesc
 * The QuestDB client's API provides methods to connect to the database, ingest data, and close the connection. &lt;br>
 * The client supports multiple transport protocols.
 * &lt;p>
 * &lt;b>Transport Options:&lt;/b>
 * &lt;ul>
 * &lt;li>&lt;b>HTTP&lt;/b>: Uses standard HTTP requests for data ingestion. Provides immediate feedback via HTTP response codes.
 * Recommended for most use cases due to superior error handling and debugging capabilities. Uses Undici library by default for high performance.&lt;/li>
 * &lt;li>&lt;b>HTTPS&lt;/b>: Secure HTTP transport with TLS encryption. Same benefits as HTTP but with encrypted communication.
 * Supports certificate validation and custom CA certificates.&lt;/li>
 * &lt;li>&lt;b>TCP&lt;/b>: Direct TCP connection, provides persistent connections. Uses JWK token-based authentication.&lt;/li>
 * &lt;li>&lt;b>TCPS&lt;/b>: Secure TCP transport with TLS encryption.&lt;/li>
 * &lt;/ul>
 * &lt;/p>
 * &lt;p>
 * The client supports authentication. &lt;br>
 * Authentication details can be passed to the Sender in its configuration options. &lt;br>
 * The client supports Basic username/password and Bearer token authentication methods when used with HTTP protocol,
 * and JWK token authentication when ingesting data via TCP. &lt;br>
 * Please, note that authentication is enabled by default in QuestDB Enterprise only. &lt;br>
 * Details on how to configure authentication in the open source version of
 * QuestDB: {@link https://questdb.io/docs/reference/api/ilp/authenticate}
 * &lt;/p>
 * &lt;p>
 * The client also supports TLS encryption for both, HTTP and TCP transports to provide a secure connection. &lt;br>
 * Please, note that the open source version of QuestDB does not support TLS, and requires an external reverse-proxy,
 * such as Nginx to enable encryption.
 * &lt;/p>
 * &lt;p>
 * The client supports multiple protocol versions for data serialization. Protocol version 1 uses text-based
 * serialization, while version 2 uses binary encoding for doubles and supports array columns for improved
 * performance. The client can automatically negotiate the protocol version with the server when using HTTP/HTTPS
 * by setting the protocol_version to 'auto' (default behavior).
 * &lt;/p>
 * &lt;p>
 * The client uses a buffer to store data. It automatically flushes the buffer by sending its content to the server.
 * Auto flushing can be disabled via configuration options to gain control over transactions. Initial and maximum
 * buffer sizes can also be set.
 * &lt;/p>
 * &lt;p>
 * It is recommended that the Sender is created by using one of the static factory methods,
 * &lt;i>Sender.fromConfig(configString, extraOptions)&lt;/i> or &lt;i>Sender.fromEnv(extraOptions)&lt;/i>.
 * If the Sender is created via its constructor, at least the SenderOptions configuration object should be
 * initialized from a configuration string to make sure that the parameters are validated. &lt;br>
 * Detailed description of the Sender's configuration options can be found in
 * the &lt;a href="SenderOptions.html">SenderOptions&lt;/a> documentation.
 * &lt;/p>
 * &lt;p>
 * &lt;b>Transport Configuration Examples:&lt;/b>
 * &lt;ul>
 * &lt;li>HTTP: &lt;i>Sender.fromConfig("http::addr=localhost:9000")&lt;/i>&lt;/li>
 * &lt;li>HTTPS with authentication: &lt;i>Sender.fromConfig("https::addr=localhost:9000;username=admin;password=secret")&lt;/i>&lt;/li>
 * &lt;li>TCP: &lt;i>Sender.fromConfig("tcp::addr=localhost:9009")&lt;/i>&lt;/li>
 * &lt;li>TCPS with authentication: &lt;i>Sender.fromConfig("tcps::addr=localhost:9009;username=user;token=private_key")&lt;/i>&lt;/li>
 * &lt;/ul>
 * &lt;/p>
 * &lt;p>
 * &lt;b>HTTP Transport Implementation:&lt;/b>&lt;br>
 * By default, HTTP/HTTPS transport uses the high-performance Undici library for connection management and request handling.
 * For compatibility or specific requirements, you can enable the standard HTTP transport using Node.js built-in modules
 * by setting &lt;i>stdlib_http=on&lt;/i> in the configuration string. The standard HTTP transport provides the same functionality
 * but uses Node.js http/https modules instead of Undici.
 * &lt;/p>
 * &lt;p>
 * Extra options can be provided to the Sender in the &lt;i>extraOptions&lt;/i> configuration object. &lt;br>
 * A custom logging function and a custom HTTP(S) agent can be passed to the Sender in this object. &lt;br>
 * The logger implementation provides the option to direct log messages to the same place where the host application's
 * log is saved. The default logger writes to the console. &lt;br>
 * The custom HTTP(S) agent option becomes handy if there is a need to modify the default options set for the
 * HTTP(S) connections. A popular setting would be disabling persistent connections, in this case an agent can be
 * passed to the Sender with &lt;i>keepAlive&lt;/i> set to &lt;i>false&lt;/i>. &lt;br>
 * For example: &lt;i>Sender.fromConfig(`http::addr=host:port`, { agent: new undici.Agent({ connect: { keepAlive: false } })})&lt;/i> &lt;br>
 * If no custom agent is configured, the Sender will use its own agent which overrides some default values
 * of &lt;i>undici.Agent&lt;/i>. The Sender's own agent uses persistent connections with 1 minute idle timeout, pipelines requests default to 1.
 * &lt;/p>
 */ class Sender {
    /**
   * Creates an instance of Sender.
   *
   * @param {SenderOptions} options - Sender configuration object. &lt;br>
   * See SenderOptions documentation for detailed description of configuration options.
   */ constructor(options){
        this.transport = createTransport(options);
        this.buffer = createBuffer(options);
        this.log = typeof options.log === "function" ? options.log : log;
        this.autoFlush = isBoolean(options.auto_flush) ? options.auto_flush : true;
        this.autoFlushRows = isInteger(options.auto_flush_rows, 0) ? options.auto_flush_rows : this.transport.getDefaultAutoFlushRows();
        this.autoFlushInterval = isInteger(options.auto_flush_interval, 0) ? options.auto_flush_interval : DEFAULT_AUTO_FLUSH_INTERVAL;
        this.reset();
    }
    /**
   * Creates a Sender object by parsing the provided configuration string.
   *
   * @param {string} configurationString - Configuration string. &lt;br>
   * @param {object} extraOptions - Optional extra configuration. &lt;br>
   * - 'log' is a logging function used by the &lt;a href="Sender.html">Sender&lt;/a>. &lt;br>
   * Prototype: &lt;i>(level: 'error'|'warn'|'info'|'debug', message: string) => void&lt;/i>. &lt;br>
   * - 'agent' is a custom http/https agent used by the &lt;a href="Sender.html">Sender&lt;/a> when http/https transport is used. &lt;br>
   * Depends on which transport implementation and protocol used, one of the followings expected: &lt;i>undici.Agent&lt;/i>, &lt;i>http.Agent&lt;/i> or &lt;i>https.Agent&lt;/i>.
   *
   * @return {Sender} A Sender object initialized from the provided configuration string.
   */ static async fromConfig(configurationString, extraOptions) {
        return new Sender(await SenderOptions.fromConfig(configurationString, extraOptions));
    }
    /**
   * Creates a Sender object by parsing the configuration string set in the &lt;b>QDB_CLIENT_CONF&lt;/b> environment variable.
   *
   * @param {object} extraOptions - Optional extra configuration. &lt;br>
   * - 'log' is a logging function used by the &lt;a href="Sender.html">Sender&lt;/a>. &lt;br>
   * Prototype: &lt;i>(level: 'error'|'warn'|'info'|'debug', message: string) => void&lt;/i>. &lt;br>
   * - 'agent' is a custom http/https agent used by the &lt;a href="Sender.html">Sender&lt;/a> when http/https transport is used. &lt;br>
   * Depends on which transport implementation and protocol used, one of the followings expected: &lt;i>undici.Agent&lt;/i>, &lt;i>http.Agent&lt;/i> or &lt;i>https.Agent&lt;/i>.
   *
   * @return {Sender} A Sender object initialized from the &lt;b>QDB_CLIENT_CONF&lt;/b> environment variable.
   */ static async fromEnv(extraOptions) {
        return new Sender(await SenderOptions.fromConfig(process.env.QDB_CLIENT_CONF, extraOptions));
    }
    /**
   * Resets the sender's buffer, data sitting in the buffer will be lost. &lt;br>
   * In other words it clears the buffer, and sets the writing position to the beginning of the buffer.
   *
   * @return {Sender} Returns with a reference to this sender.
   */ reset() {
        this.buffer.reset();
        this.resetAutoFlush();
        return this;
    }
    /**
   * Creates a TCP connection to the database.
   *
   * @return {Promise&lt;boolean>} Resolves to true if the client is connected.
   */ connect() {
        return this.transport.connect();
    }
    /**
   * Sends the content of the sender's buffer to the database and compacts the buffer.
   * If the last row is not finished it stays in the sender's buffer.
   *
   * @return {Promise&lt;boolean>} Resolves to true when there was data in the buffer to send, and it was sent successfully.
   */ async flush() {
        const dataToSend = this.buffer.toBufferNew();
        if (!dataToSend) {
            return false; // Nothing to send
        }
        this.log("debug", `Flushing, number of flushed rows: ${this.pendingRowCount}`);
        this.resetAutoFlush();
        await this.transport.send(dataToSend);
    }
    /**
   * Closes the connection to the database. &lt;br>
   * Data sitting in the Sender's buffer will be lost unless flush() is called before close().
   */ async close() {
        const pos = this.buffer.currentPosition();
        if (pos > 0) {
            this.log("warn", `Buffer contains data which has not been flushed before closing the sender, and it will be lost [position=${pos}]`);
        }
        return this.transport.close();
    }
    /**
   * Writes the table name into the buffer of the sender of the sender.
   *
   * @param {string} table - Table name.
   * @return {Sender} Returns with a reference to this sender.
   */ table(table) {
        this.buffer.table(table);
        return this;
    }
    /**
   * Writes a symbol name and value into the buffer of the sender. &lt;br>
   * Use it to insert into SYMBOL columns.
   *
   * @param {string} name - Symbol name.
   * @param {unknown} value - Symbol value, toString() is called to extract the actual symbol value from the parameter.
   * @return {Sender} Returns with a reference to this sender.
   */ symbol(name, value) {
        this.buffer.symbol(name, value);
        return this;
    }
    /**
   * Writes a string column with its value into the buffer of the sender. &lt;br>
   * Use it to insert into VARCHAR and STRING columns.
   *
   * @param {string} name - Column name.
   * @param {string} value - Column value, accepts only string values.
   * @return {Sender} Returns with a reference to this sender.
   */ stringColumn(name, value) {
        this.buffer.stringColumn(name, value);
        return this;
    }
    /**
   * Writes a boolean column with its value into the buffer of the sender. &lt;br>
   * Use it to insert into BOOLEAN columns.
   *
   * @param {string} name - Column name.
   * @param {boolean} value - Column value, accepts only boolean values.
   * @return {Sender} Returns with a reference to this sender.
   */ booleanColumn(name, value) {
        this.buffer.booleanColumn(name, value);
        return this;
    }
    /**
   * Writes a 64-bit floating point value into the buffer of the sender. &lt;br>
   * Use it to insert into DOUBLE or FLOAT database columns.
   *
   * @param {string} name - Column name.
   * @param {number} value - Column value, accepts only number values.
   * @return {Sender} Returns with a reference to this sender.
   */ floatColumn(name, value) {
        this.buffer.floatColumn(name, value);
        return this;
    }
    /**
   * Writes an array column with its values into the buffer of the sender.
   *
   * @param {string} name - Column name
   * @param {unknown[]} value - Array values to write (currently supports double arrays)
   * @returns {Sender} Returns with a reference to this sender.
   * @throws Error if arrays are not supported by the buffer implementation, or array validation fails:
   * - value is not an array
   * - or the shape of the array is irregular: the length of sub-arrays are different
   * - or the array is not homogeneous: its elements are not all the same type
   */ arrayColumn(name, value) {
        this.buffer.arrayColumn(name, value);
        return this;
    }
    /**
   * Writes a 64-bit signed integer into the buffer of the sender. &lt;br>
   * Use it to insert into LONG, INT, SHORT and BYTE columns.
   *
   * @param {string} name - Column name.
   * @param {number} value - Column value, accepts only number values.
   * @return {Sender} Returns with a reference to this sender.
   * @throws Error if the value is not an integer
   */ intColumn(name, value) {
        this.buffer.intColumn(name, value);
        return this;
    }
    /**
   * Writes a timestamp column with its value into the buffer of the sender. &lt;br>
   * Use it to insert into TIMESTAMP columns.
   *
   * @param {string} name - Column name.
   * @param {number | bigint} value - Epoch timestamp, accepts numbers or BigInts.
   * @param {string} [unit=us] - Timestamp unit. Supported values: 'ns' - nanoseconds, 'us' - microseconds, 'ms' - milliseconds. Defaults to 'us'.
   * @return {Sender} Returns with a reference to this sender.
   */ timestampColumn(name, value, unit = "us") {
        this.buffer.timestampColumn(name, value, unit);
        return this;
    }
    /**
   * Closes the row after writing the designated timestamp into the buffer of the sender.
   *
   * @param {number | bigint} timestamp - Designated epoch timestamp, accepts numbers or BigInts.
   * @param {string} [unit=us] - Timestamp unit. Supported values: 'ns' - nanoseconds, 'us' - microseconds, 'ms' - milliseconds. Defaults to 'us'.
   */ async at(timestamp, unit = "us") {
        this.buffer.at(timestamp, unit);
        this.pendingRowCount++;
        this.log("debug", `Pending row count: ${this.pendingRowCount}`);
        await this.tryFlush();
    }
    /**
   * Closes the row without writing designated timestamp into the buffer of the sender. &lt;br>
   * Designated timestamp will be populated by the server on this record.
   */ async atNow() {
        this.buffer.atNow();
        this.pendingRowCount++;
        this.log("debug", `Pending row count: ${this.pendingRowCount}`);
        await this.tryFlush();
    }
    resetAutoFlush() {
        this.lastFlushTime = Date.now();
        this.pendingRowCount = 0;
        this.log("debug", `Pending row count: ${this.pendingRowCount}`);
    }
    async tryFlush() {
        if (this.autoFlush &amp;&amp; this.pendingRowCount > 0 &amp;&amp; (this.autoFlushRows > 0 &amp;&amp; this.pendingRowCount >= this.autoFlushRows || this.autoFlushInterval > 0 &amp;&amp; Date.now() - this.lastFlushTime >= this.autoFlushInterval)) {
            await this.flush();
        }
    }
}

exports.Sender = Sender;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HttpTransport.html">HttpTransport</a></li><li><a href="HttpTransportBase.html">HttpTransportBase</a></li><li><a href="Sender.html">Sender</a></li><li><a href="SenderBufferBase.html">SenderBufferBase</a></li><li><a href="SenderBufferV1.html">SenderBufferV1</a></li><li><a href="SenderBufferV2.html">SenderBufferV2</a></li><li><a href="SenderOptions.html">SenderOptions</a></li><li><a href="TcpTransport.html">TcpTransport</a></li><li><a href="UndiciTransport.html">UndiciTransport</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_HTTP_AGENT_CONFIG">DEFAULT_HTTP_AGENT_CONFIG</a></li><li><a href="global.html#DEFAULT_HTTP_OPTIONS">DEFAULT_HTTP_OPTIONS</a></li><li><a href="global.html#createBuffer">createBuffer</a></li><li><a href="global.html#createTransport">createTransport</a></li><li><a href="global.html#fetchJson">fetchJson</a></li><li><a href="global.html#getDimensions">getDimensions</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isInteger">isInteger</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#timestampToMicros">timestampToMicros</a></li><li><a href="global.html#timestampToNanos">timestampToNanos</a></li><li><a href="global.html#validateArray">validateArray</a></li><li><a href="global.html#validateColumnName">validateColumnName</a></li><li><a href="global.html#validateTableName">validateTableName</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Aug 06 2025 23:19:11 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
